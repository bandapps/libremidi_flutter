// =============================================================================
// DO NOT IMPORT THIS FILE DIRECTLY.
// Use package:libremidi_flutter/libremidi_flutter.dart instead.
// =============================================================================
//
// This file is auto-generated by ffigen. Manual changes will be overwritten.
// Regenerate with: dart run ffigen --config ffigen.yaml
//
// ignore_for_file: always_specify_types, camel_case_types, non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

/// Bindings for `src/libremidi_flutter.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class LibremidiFlutterBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibremidiFlutterBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibremidiFlutterBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// Get library version string
  ffi.Pointer<ffi.Char> lrm_get_version() {
    return _lrm_get_version();
  }

  late final _lrm_get_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'lrm_get_version',
      );
  late final _lrm_get_version = _lrm_get_versionPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Create a new observer for enumerating MIDI ports
  ffi.Pointer<LrmObserver> lrm_observer_new() {
    return _lrm_observer_new();
  }

  late final _lrm_observer_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<LrmObserver> Function()>>(
        'lrm_observer_new',
      );
  late final _lrm_observer_new = _lrm_observer_newPtr
      .asFunction<ffi.Pointer<LrmObserver> Function()>();

  /// Create a new observer with hotplug callback
  ffi.Pointer<LrmObserver> lrm_observer_new_with_callbacks(
    LrmHotplugCallback callback,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _lrm_observer_new_with_callbacks(callback, context);
  }

  late final _lrm_observer_new_with_callbacksPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<LrmObserver> Function(
            LrmHotplugCallback,
            ffi.Pointer<ffi.Void>,
          )
        >
      >('lrm_observer_new_with_callbacks');
  late final _lrm_observer_new_with_callbacks =
      _lrm_observer_new_with_callbacksPtr
          .asFunction<
            ffi.Pointer<LrmObserver> Function(
              LrmHotplugCallback,
              ffi.Pointer<ffi.Void>,
            )
          >();

  /// Free the observer
  void lrm_observer_free(ffi.Pointer<LrmObserver> observer) {
    return _lrm_observer_free(observer);
  }

  late final _lrm_observer_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LrmObserver>)>>(
        'lrm_observer_free',
      );
  late final _lrm_observer_free = _lrm_observer_freePtr
      .asFunction<void Function(ffi.Pointer<LrmObserver>)>();

  /// Refresh port list
  void lrm_observer_refresh(ffi.Pointer<LrmObserver> observer) {
    return _lrm_observer_refresh(observer);
  }

  late final _lrm_observer_refreshPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LrmObserver>)>>(
        'lrm_observer_refresh',
      );
  late final _lrm_observer_refresh = _lrm_observer_refreshPtr
      .asFunction<void Function(ffi.Pointer<LrmObserver>)>();

  /// Get count of available input ports
  int lrm_observer_get_input_count(ffi.Pointer<LrmObserver> observer) {
    return _lrm_observer_get_input_count(observer);
  }

  late final _lrm_observer_get_input_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<LrmObserver>)>>(
        'lrm_observer_get_input_count',
      );
  late final _lrm_observer_get_input_count = _lrm_observer_get_input_countPtr
      .asFunction<int Function(ffi.Pointer<LrmObserver>)>();

  /// Get count of available output ports
  int lrm_observer_get_output_count(ffi.Pointer<LrmObserver> observer) {
    return _lrm_observer_get_output_count(observer);
  }

  late final _lrm_observer_get_output_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<LrmObserver>)>>(
        'lrm_observer_get_output_count',
      );
  late final _lrm_observer_get_output_count = _lrm_observer_get_output_countPtr
      .asFunction<int Function(ffi.Pointer<LrmObserver>)>();

  /// Get input port info by index (returns 0 on success, fills info struct)
  int lrm_observer_get_input(
    ffi.Pointer<LrmObserver> observer,
    int index,
    ffi.Pointer<LrmPortInfo> info,
  ) {
    return _lrm_observer_get_input(observer, index, info);
  }

  late final _lrm_observer_get_inputPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int32 Function(
            ffi.Pointer<LrmObserver>,
            ffi.Int32,
            ffi.Pointer<LrmPortInfo>,
          )
        >
      >('lrm_observer_get_input');
  late final _lrm_observer_get_input = _lrm_observer_get_inputPtr
      .asFunction<
        int Function(ffi.Pointer<LrmObserver>, int, ffi.Pointer<LrmPortInfo>)
      >();

  /// Get output port info by index (returns 0 on success, fills info struct)
  int lrm_observer_get_output(
    ffi.Pointer<LrmObserver> observer,
    int index,
    ffi.Pointer<LrmPortInfo> info,
  ) {
    return _lrm_observer_get_output(observer, index, info);
  }

  late final _lrm_observer_get_outputPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int32 Function(
            ffi.Pointer<LrmObserver>,
            ffi.Int32,
            ffi.Pointer<LrmPortInfo>,
          )
        >
      >('lrm_observer_get_output');
  late final _lrm_observer_get_output = _lrm_observer_get_outputPtr
      .asFunction<
        int Function(ffi.Pointer<LrmObserver>, int, ffi.Pointer<LrmPortInfo>)
      >();

  /// Open a MIDI output port by index
  ffi.Pointer<LrmMidiOut> lrm_midi_out_open(
    ffi.Pointer<LrmObserver> observer,
    int port_index,
  ) {
    return _lrm_midi_out_open(observer, port_index);
  }

  late final _lrm_midi_out_openPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<LrmMidiOut> Function(ffi.Pointer<LrmObserver>, ffi.Int32)
        >
      >('lrm_midi_out_open');
  late final _lrm_midi_out_open = _lrm_midi_out_openPtr
      .asFunction<
        ffi.Pointer<LrmMidiOut> Function(ffi.Pointer<LrmObserver>, int)
      >();

  /// Close and free a MIDI output
  void lrm_midi_out_close(ffi.Pointer<LrmMidiOut> midi_out) {
    return _lrm_midi_out_close(midi_out);
  }

  late final _lrm_midi_out_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LrmMidiOut>)>>(
        'lrm_midi_out_close',
      );
  late final _lrm_midi_out_close = _lrm_midi_out_closePtr
      .asFunction<void Function(ffi.Pointer<LrmMidiOut>)>();

  /// Check if output is connected
  bool lrm_midi_out_is_connected(ffi.Pointer<LrmMidiOut> midi_out) {
    return _lrm_midi_out_is_connected(midi_out);
  }

  late final _lrm_midi_out_is_connectedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LrmMidiOut>)>>(
        'lrm_midi_out_is_connected',
      );
  late final _lrm_midi_out_is_connected = _lrm_midi_out_is_connectedPtr
      .asFunction<bool Function(ffi.Pointer<LrmMidiOut>)>();

  /// Send a MIDI message
  int lrm_midi_out_send(
    ffi.Pointer<LrmMidiOut> midi_out,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _lrm_midi_out_send(midi_out, data, length);
  }

  late final _lrm_midi_out_sendPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int32 Function(
            ffi.Pointer<LrmMidiOut>,
            ffi.Pointer<ffi.Uint8>,
            ffi.Size,
          )
        >
      >('lrm_midi_out_send');
  late final _lrm_midi_out_send = _lrm_midi_out_sendPtr
      .asFunction<
        int Function(ffi.Pointer<LrmMidiOut>, ffi.Pointer<ffi.Uint8>, int)
      >();

  /// Open a MIDI input port by index
  /// The callback will be called on a background thread when messages arrive
  /// receive_sysex: if true, SysEx messages (F0..F7) are passed to callback
  /// receive_timing: if true, MIDI clock messages (F8) are passed to callback
  /// receive_sensing: if true, active sensing messages (FE) are passed to callback
  ffi.Pointer<LrmMidiIn> lrm_midi_in_open(
    ffi.Pointer<LrmObserver> observer,
    int port_index,
    LrmMidiCallback callback,
    ffi.Pointer<ffi.Void> context,
    bool receive_sysex,
    bool receive_timing,
    bool receive_sensing,
  ) {
    return _lrm_midi_in_open(
      observer,
      port_index,
      callback,
      context,
      receive_sysex,
      receive_timing,
      receive_sensing,
    );
  }

  late final _lrm_midi_in_openPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<LrmMidiIn> Function(
            ffi.Pointer<LrmObserver>,
            ffi.Int32,
            LrmMidiCallback,
            ffi.Pointer<ffi.Void>,
            ffi.Bool,
            ffi.Bool,
            ffi.Bool,
          )
        >
      >('lrm_midi_in_open');
  late final _lrm_midi_in_open = _lrm_midi_in_openPtr
      .asFunction<
        ffi.Pointer<LrmMidiIn> Function(
          ffi.Pointer<LrmObserver>,
          int,
          LrmMidiCallback,
          ffi.Pointer<ffi.Void>,
          bool,
          bool,
          bool,
        )
      >();

  /// Close and free a MIDI input
  void lrm_midi_in_close(ffi.Pointer<LrmMidiIn> midi_in) {
    return _lrm_midi_in_close(midi_in);
  }

  late final _lrm_midi_in_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<LrmMidiIn>)>>(
        'lrm_midi_in_close',
      );
  late final _lrm_midi_in_close = _lrm_midi_in_closePtr
      .asFunction<void Function(ffi.Pointer<LrmMidiIn>)>();

  /// Check if input is connected
  bool lrm_midi_in_is_connected(ffi.Pointer<LrmMidiIn> midi_in) {
    return _lrm_midi_in_is_connected(midi_in);
  }

  late final _lrm_midi_in_is_connectedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<LrmMidiIn>)>>(
        'lrm_midi_in_is_connected',
      );
  late final _lrm_midi_in_is_connected = _lrm_midi_in_is_connectedPtr
      .asFunction<bool Function(ffi.Pointer<LrmMidiIn>)>();
}

final class LrmObserver extends ffi.Opaque {}

final class LrmMidiIn extends ffi.Opaque {}

final class LrmMidiOut extends ffi.Opaque {}

final class LrmPortInfo extends ffi.Struct {
  /// Cross-platform stable ID (survives hotplug/reorder)
  @ffi.Uint64()
  external int stable_id;

  /// Unique port ID (CoreMIDI: kMIDIPropertyUniqueID)
  @ffi.Uint64()
  external int port_id;

  /// API client handle
  @ffi.Uint64()
  external int client_handle;

  /// Index in enumeration (may change on hotplug)
  @ffi.Int32()
  external int index;

  /// Full display name (e.g. "IAC Driver Bus 1")
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> display_name;

  /// Port name (e.g. "Bus 1")
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> port_name;

  /// Device/model name (e.g. "IAC Driver")
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> device_name;

  /// Manufacturer name
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> manufacturer;

  /// Product name
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> product;

  /// Serial number (often empty)
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> serial;

  /// Transport type (software, usb, bluetooth, etc.)
  @ffi.Uint8()
  external int transport_type;

  /// true = input, false = output
  @ffi.Bool()
  external bool is_input;

  /// true if virtual/software port
  @ffi.Bool()
  external bool is_virtual;
}

typedef LrmMidiCallbackFunction =
    ffi.Void Function(
      ffi.Pointer<ffi.Void> context,
      ffi.Pointer<ffi.Uint8> data,
      ffi.Size length,
      ffi.Int64 timestamp,
    );
typedef DartLrmMidiCallbackFunction =
    void Function(
      ffi.Pointer<ffi.Void> context,
      ffi.Pointer<ffi.Uint8> data,
      int length,
      int timestamp,
    );

/// Called when MIDI message is received
typedef LrmMidiCallback =
    ffi.Pointer<ffi.NativeFunction<LrmMidiCallbackFunction>>;
typedef LrmHotplugCallbackFunction =
    ffi.Void Function(ffi.Pointer<ffi.Void> context, ffi.Int32 event_type);
typedef DartLrmHotplugCallbackFunction =
    void Function(ffi.Pointer<ffi.Void> context, int event_type);

/// Called when MIDI device is added or removed
/// event_type: 0 = input_added, 1 = input_removed, 2 = output_added, 3 = output_removed
typedef LrmHotplugCallback =
    ffi.Pointer<ffi.NativeFunction<LrmHotplugCallbackFunction>>;

const int LRM_OK = 0;

const int LRM_ERR_INVALID = -1;

const int LRM_ERR_NOT_FOUND = -2;

const int LRM_ERR_OPEN_FAILED = -3;

const int LRM_ERR_SEND_FAILED = -4;

const int LRM_ERR_INIT_FAILED = -5;

const int LRM_TRANSPORT_UNKNOWN = 0;

const int LRM_TRANSPORT_SOFTWARE = 2;

const int LRM_TRANSPORT_LOOPBACK = 4;

const int LRM_TRANSPORT_HARDWARE = 8;

const int LRM_TRANSPORT_USB = 16;

const int LRM_TRANSPORT_BLUETOOTH = 32;

const int LRM_TRANSPORT_PCI = 64;

const int LRM_TRANSPORT_NETWORK = 128;
